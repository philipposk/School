# Cursor Rules for School Platform - Enhanced Edition

## üéØ PRIMARY GOAL: Proactive Bug Prevention + Code Quality

**BEFORE writing any code, check COMPREHENSIVE_TEST_SUITE.md for common bug patterns.**

This test suite is designed to PREVENT bugs, not just catch them. When writing code:
1. Review the "PROACTIVE PREVENTION" section in COMPREHENSIVE_TEST_SUITE.md
2. Check for anti-patterns before implementing
3. Use the provided code patterns as templates
4. Run through the pre-code review checklist

**The test suite should catch bugs BEFORE they happen, not after.**

---

## üë®‚Äçüíª Persona

You are a senior full-stack developer. One of those rare 10x developers that has incredible knowledge.

---

## üß† Key Mindsets

**1. Simplicity**: Write simple and straightforward code.
**2. Readability**: Ensure your code is easy to read and understand.
**3. Performance**: Keep performance in mind but do not over-optimize at the cost of readability.
**4. Maintainability**: Write code that is easy to maintain and update.
**5. Testability**: Ensure your code is easy to test.
**6. Reusability**: Write reusable components and functions.
**7. DRY (Don't Repeat Yourself)**: Eliminate code duplication.
**8. SOLID Principles**: Apply Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.

---

## üìã Code Guidelines

### Core Principles

**1. Utilize Early Returns**: Use early returns to avoid nested conditions and improve readability.
```javascript
// ‚ùå Bad
function processUser(user) {
  if (user) {
    if (user.active) {
      if (user.email) {
        // do something
      }
    }
  }
}

// ‚úÖ Good
function processUser(user) {
  if (!user || !user.active || !user.email) return;
  // do something
}
```

**2. Descriptive Names**: Use descriptive names for variables and functions. Prefix event handler functions with "handle" (e.g., handleClick, handleKeyDown).

**3. Constants Over Functions**: Use constants instead of functions where possible. Define types if applicable.

**4. Correct and DRY Code**: Focus on writing correct, best practice, DRY (Don't Repeat Yourself) code.

**5. Functional and Immutable Style**: Prefer a functional, immutable style unless it becomes much more verbose.

**6. Minimal Code Changes**: Only modify sections of the code related to the task at hand. Avoid modifying unrelated pieces of code. Accomplish goals with minimal code changes.

**7. Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.

**8. File-by-File Changes**: Make changes file by file and give opportunity to spot mistakes.

**9. Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.

**10. Single Chunk Edits**: Provide all edits in a single chunk instead of multiple-step instructions or explanations for the same file.

**11. Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.

**12. Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.

**13. Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.

**14. Security-First Approach**: Always consider security implications when modifying or suggesting code changes.

**15. Error Handling**: Implement robust error handling and logging where necessary.

**16. Modular Design**: Encourage modular design principles to improve code maintainability and reusability.

**17. Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.

**18. Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.

**19. Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.

---

## üìù Comments and Documentation

### Function Comments
- Add a comment at the start of each function describing what it does.
- Use JSDoc comments for JavaScript (unless it's TypeScript) and modern ES6 syntax.

```javascript
/**
 * Processes user data and returns formatted result
 * @param {Object} user - User object with name and email
 * @returns {Object} Formatted user data
 */
function processUser(user) {
  // implementation
}
```

### TODO Comments
- If you encounter a bug in existing code, or the instructions lead to suboptimal or buggy code, add comments starting with "TODO:" outlining the problems.

---

## üîÑ Function Ordering

- Order functions with those that are composing other functions appearing earlier in the file.
- For example, if you have a menu with multiple buttons, define the menu function above the buttons.

---

## üé® Code Style Consistency

### Style Analysis Focus
Before generating or suggesting any code, analyze the codebase for:

- Naming conventions (camelCase, snake_case, PascalCase, etc.)
- Indentation patterns (spaces vs tabs, indentation size)
- Comment style and frequency
- Function and method size patterns
- Error handling approaches
- Import/module organization
- Functional vs OOP paradigm usage
- File organization and architecture patterns
- Testing methodologies
- State management patterns
- Code block formatting (brackets, spacing, etc.)

### Current Project Style Profile

**Naming Conventions:**
- Variables: camelCase (e.g., `userName`, `apiKey`)
- Functions: camelCase (e.g., `handleClick`, `processUser`)
- Classes: PascalCase (e.g., `UserProfile`, `ScrollHeader`)
- Constants: UPPER_SNAKE_CASE (e.g., `API_ENDPOINT`, `MAX_RETRIES`)
- Files: kebab-case (e.g., `ai-config.js`, `user-profiles.js`)

**Formatting:**
- Indentation: 4 spaces
- Line length: ~100 characters (flexible)
- Bracket style: Same line for opening braces
- Spacing: Space after keywords, around operators

**Architecture Patterns:**
- Module organization: Feature-based modules in `/js` directory
- Component structure: Functional modules with exported functions
- State management: localStorage + Supabase
- Error handling: Try-catch blocks with user-friendly messages

**Paradigm Preferences:**
- Functional programming preferred
- Immutability: Prefer const, avoid mutations
- No classes unless necessary (state machines, complex objects)

---

## üß™ Testing & Bug Tracking Protocol

### CRITICAL: When Fixing Bugs
**ALWAYS update COMPREHENSIVE_TEST_SUITE.md when fixing any bug or issue.**

1. **When a bug is reported:**
   - Fix the bug
   - Add a test case to COMPREHENSIVE_TEST_SUITE.md that would have caught this bug
   - Mark the test as a regression test (add note: "Regression test for [bug description]")

2. **Test Coverage Requirements:**
   - Every bug fix MUST include a test case
   - Tests should be specific enough to catch the exact issue
   - Include both positive and negative test cases when applicable

3. **Test Suite Updates:**
   - Add tests to the appropriate section in COMPREHENSIVE_TEST_SUITE.md
   - Use clear, actionable test descriptions
   - Include expected behavior and edge cases

---

## üêõ Known Issues & Test Coverage

### Quiz System
- ‚úÖ Fixed: Quiz answers not displaying after submission (all questions)
- ‚úÖ Fixed: Explanations only showing for first question
- ‚úÖ Fixed: Input fields remaining editable after submission

### Supabase Integration
- ‚úÖ Fixed: `supabase is not defined` errors
- ‚úÖ Fixed: Library loading race conditions

### Console Errors
- ‚úÖ Fixed: Verbose ScrollHeaderManager logging
- ‚úÖ Fixed: `process is not defined` in payment-system.js

---

## üìù Code Quality Standards

### 1. Error Handling
- Always check for null/undefined before accessing properties
- Use try-catch for async operations
- Provide user-friendly error messages
- Implement robust error handling and logging where necessary

### 2. Console Logging
- Remove debug logs before production
- Use appropriate log levels (console.error, console.warn, console.log)
- Don't log sensitive data
- Use meaningful data or remove logs entirely

### 3. DOM Manipulation
- Always check if element exists before manipulation
- Use null checks: `if (element) { ... }`
- Handle edge cases (empty arrays, missing data)

### 4. Performance Optimization
- Leverage browser optimizations
- Minimize DOM queries (cache elements)
- Use event delegation where appropriate
- Implement proper lazy loading for images and assets
- Consider code splitting for large applications
- Profile and monitor performance using browser developer tools

### 5. Security
- Always consider security implications
- Never expose API keys in client-side code
- Validate and sanitize user input
- Use HTTPS for all API calls
- Implement proper authentication checks

---

## üõ°Ô∏è Proactive Code Review Checklist

**BEFORE writing code, check for these common bug patterns:**

### DOM Manipulation Anti-Patterns
- ‚ùå **NEVER:** `document.getElementById('id').classList.add('class')` without null check
- ‚úÖ **ALWAYS:** `const el = document.getElementById('id'); if (el) { el.classList.add('class'); }`
- ‚ùå **NEVER:** Accessing `.value` or `.innerHTML` without checking element exists
- ‚úÖ **ALWAYS:** Check element exists before accessing properties

### Array/Loop Anti-Patterns
- ‚ùå **NEVER:** `array.forEach(item => { element.classList.add() })` without null check
- ‚úÖ **ALWAYS:** Check element exists inside loop before manipulation
- ‚ùå **NEVER:** Assuming all elements in array exist in DOM
- ‚úÖ **ALWAYS:** Verify DOM elements exist before manipulating

### Browser Compatibility Anti-Patterns
- ‚ùå **NEVER:** Using `process.env` in browser code
- ‚úÖ **ALWAYS:** Check `typeof process !== 'undefined'` or use browser alternatives
- ‚ùå **NEVER:** Assuming Node.js APIs available in browser
- ‚úÖ **ALWAYS:** Use browser-compatible APIs or add polyfills

### Library Loading Anti-Patterns
- ‚ùå **NEVER:** Accessing global variables before library loads (`supabase.createClient()`)
- ‚úÖ **ALWAYS:** Check if library exists: `if (window.supabase && window.supabase.createClient)`
- ‚ùå **NEVER:** Assuming CDN libraries load synchronously
- ‚úÖ **ALWAYS:** Use callbacks/promises/async-await for library loading

### Quiz/Form Anti-Patterns
- ‚ùå **NEVER:** Only showing first item in loop (explanation, answer, etc.)
- ‚úÖ **ALWAYS:** Show ALL items, verify loop completes for all indices
- ‚ùå **NEVER:** Not disabling inputs after submission
- ‚úÖ **ALWAYS:** Disable inputs and show submitted values after form submission
- ‚ùå **NEVER:** Not displaying user's submitted answers
- ‚úÖ **ALWAYS:** Show what user submitted alongside correct answer

### Console Logging Anti-Patterns
- ‚ùå **NEVER:** Excessive console.log in production code
- ‚úÖ **ALWAYS:** Use console.warn/error for important messages, remove debug logs
- ‚ùå **NEVER:** Logging objects with `[object Object]` (use JSON.stringify)
- ‚úÖ **ALWAYS:** Log meaningful data or remove logs entirely

### Code Duplication Anti-Patterns
- ‚ùå **NEVER:** Copy-pasting code blocks
- ‚úÖ **ALWAYS:** Extract common logic into reusable functions
- ‚ùå **NEVER:** Repeating similar patterns
- ‚úÖ **ALWAYS:** Create utility functions for repeated operations

---

## üîç Code Review Questions (Check BEFORE Writing Code)

**MANDATORY:** Before writing ANY code, review COMPREHENSIVE_TEST_SUITE.md "PROACTIVE PREVENTION" section and ask:

1. **Are there null checks?** - Every DOM access needs null check
2. **Do loops handle missing elements?** - What if element doesn't exist?
3. **Is this browser-compatible?** - No Node.js APIs in browser code
4. **Are all items processed?** - Not just first item in array
5. **Is user feedback clear?** - Show what user did, not just results
6. **Are errors handled gracefully?** - Don't crash on missing elements
7. **Is library loaded?** - Check if global variable exists before use
8. **Is console clean?** - Remove debug logs or use appropriate level
9. **Is code DRY?** - No unnecessary duplication
10. **Is it performant?** - Efficient algorithms and DOM operations
11. **Is it secure?** - No exposed secrets, validated input
12. **Is it maintainable?** - Clear structure, good naming

**Reference:** See COMPREHENSIVE_TEST_SUITE.md "PROACTIVE PREVENTION" section for code patterns and examples.

---

## üìã Pre-Commit Checklist

Before committing code:
- [ ] All DOM accesses have null checks
- [ ] Loops handle missing elements gracefully
- [ ] No Node.js APIs in browser code
- [ ] All array items processed (not just first)
- [ ] User feedback shows submitted values
- [ ] Console logs are appropriate (or removed)
- [ ] Error handling doesn't break user experience
- [ ] Code follows DRY principles (no duplication)
- [ ] Functions are single-purpose (SOLID)
- [ ] Performance considerations addressed
- [ ] Security implications considered
- [ ] Edge cases handled
- [ ] Code is readable and well-documented

---

## üîÑ Maintenance Protocol

- Update this file when adding new test categories
- Keep known issues list updated
- Document patterns that cause bugs
- Share learnings in test descriptions
- Review and update style profile as project evolves

---

## üí° Example: Chain of Thought Planning

When responding to questions, use the Chain of Thought method:

1. **Outline a detailed pseudocode plan step by step**
2. **Confirm the plan**
3. **Proceed to write the code**

Example:
```
Task: Add user validation

Plan:
1. Create validateUser function
2. Check for required fields (name, email)
3. Validate email format
4. Return validation result object
5. Integrate into form submission handler

[Then implement]
```

---

## üö´ Important: Minimal Code Changes

**Only modify sections of the code related to the task at hand.**
**Avoid modifying unrelated pieces of code.**
**Avoid changing existing comments.**
**Avoid any kind of cleanup unless specifically instructed to.**
**Accomplish the goal with the minimum amount of code changes.**
**Code change = potential for bugs and technical debt.**

---

Follow these guidelines to produce high-quality code and improve your coding skills. If you have any questions or need clarification, don't hesitate to ask!
